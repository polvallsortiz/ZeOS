[ ] Download ZeOS
[ ] Install ZeOS
---
		tar zxf zeos.tar.gz
---
[ ] Generate ZeOS. This means generating the 'zeos.bin' file which contains the boot sector, the user code and the code for the operating system (the kernel).
---
		make
---
[ ] Examine (and write down) the output of the previous command, as it explains the zeos.bin generation, specially which files are needed to generate the intermediate binaries.


gcc -m32 -E -Iinclude -traditional bootsect.S -o bootsect.s
as86 -0 -a -o bootsect.o bootsect.s
ld86 -0 -s -o bootsect bootsect.o
gcc -m32 -O2  -g  -fno-omit-frame-pointer -ffreestanding -Wall -Iinclude   -c -o interrupt.o interrupt.c
gcc -m32 -E -Iinclude -o entry.s entry.S
as --32   -o entry.o entry.s
gcc -m32 -E -Iinclude -o sys_call_table.s sys_call_table.S
as --32   -o sys_call_table.o sys_call_table.s
gcc -m32 -O2  -g  -fno-omit-frame-pointer -ffreestanding -Wall -Iinclude   -c -o io.o io.c
gcc -m32 -O2  -g  -fno-omit-frame-pointer -ffreestanding -Wall -Iinclude   -c -o sched.o sched.c
gcc -m32 -O2  -g  -fno-omit-frame-pointer -ffreestanding -Wall -Iinclude   -c -o sys.o sys.c
gcc -m32 -O2  -g  -fno-omit-frame-pointer -ffreestanding -Wall -Iinclude   -c -o mm.o mm.c
gcc -m32 -O2  -g  -fno-omit-frame-pointer -ffreestanding -Wall -Iinclude   -c -o devices.o devices.c
gcc -m32 -O2  -g  -fno-omit-frame-pointer -ffreestanding -Wall -Iinclude   -c -o utils.o utils.c
gcc -m32 -O2  -g  -fno-omit-frame-pointer -ffreestanding -Wall -Iinclude   -c -o hardware.o hardware.c
gcc -m32 -O2  -g  -fno-omit-frame-pointer -ffreestanding -Wall -Iinclude   -c -o list.o list.c
gcc -m32 -O2  -g  -fno-omit-frame-pointer -ffreestanding -Wall -Iinclude   -c -o system.o system.c
ld -melf_i386 -g -T system.lds -o system system.o interrupt.o entry.o sys_call_table.o io.o sched.o sys.o mm.o devices.o utils.o hardware.o list.o -L . -l zeos 
gcc -Wall -Wstrict-prototypes -g -o build build.c
gcc -m32 -O2  -g  -fno-omit-frame-pointer -ffreestanding -Wall -Iinclude   -c -o user.o user.c
gcc -m32 -O2  -g  -fno-omit-frame-pointer -ffreestanding -Wall -Iinclude   -c -o libc.o libc.c
ld -melf_i386 -g -T user.lds -o user user.o libc.o 
objcopy -O binary -R .note -R .comment -S system system.out
objcopy -O binary -R .note -R .comment -S user user.out
./build bootsect system.out user.out > zeos.bin
Boot sector 512 bytes.
System is 144 kB
User is 32 kB
Image is 176 kB



[ ] Test your OS (without debugger, using 'bochs' binary):
---
		make emul
---
[ ] Test your OS (again) manually:
---
		bochs -q
---
[ ] Where is ZeOS hanged? (This is a typical situation in the lab where you need to know which code is being executed)

It's hanged in this instruction:
  while(1) {

   }

  100003:       eb fe                   jmp    100003 <main+0x3>

		- Look the dissassembly of the main function in the 'user' binary which corresponds to the main function in user.c.
---
			objdump -d user | less
---
		- It shows a listing of address + code
		- Can you explain what is it doing?
Dissasembling the code
		- Start the internal debugger (it uses the 'bochs_nogdb' binary)
---
			make emuldbg
---
			- Start the execution of the image inside the debugger with the 'continue' command (or 'c').
			- Stop the execution of the emulation with Ctrl-C.
			- It now shows the next memory address to be loaded in the EIP (next instruction to be executed) and its corresponding value translated to assembly.
			- Which is this address? match it with the disassembly code shown before.

[ ] Modify the user code, adding a couple of functions 'inner' and 'outer' as explained in the Zeos document (section 2.5.2).
	Using the debugger you need to learn how to:
	- Stop the execution at a predefined position using a breakpoint: break ADDRESS
	- Examine content of the registers: r
	- Examine content of the stack: print-stack
	- Examine content of memory: x ADDRESS
	- Delete breakpoints: del
	- Continue the execution of the image until a predefined point: continue
	- Execute a single assembly instruction: step
	- Execute a single assembly instruction, but if the instruction is a call, then executes it completely: next
	[ ] Which is the final value of 'acum'?
	67525
	[ ] Which is the value of 'acum' at the first iteration of 'outer'? Where is it stored? If it is in a register indicate which one, if it is in the stack indicate which address.
	It's value is 1, and it's located at %ebp - 8 that it's 0x11bfc8
	[ ] Which is the value of 'acum' at the iteration 50 in the 'outer' loop? [This question is hard, do not invest more than 15 minutes]
	19600
[ ] Do the same using the external debugger (GDB). Try the TUI.

[ ] Add the function 'add' explained in the Zeos document. Compile it and write down the assembly code of this function.
[ ] Create an assembler version of the 'add' C function using asembler inline, and test that it works as expected as explained in the Zeos document (section 2.5.3).
